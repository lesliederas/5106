# -*- coding: utf-8 -*-
"""HW1Part1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JQ4d8xO6NYWFgY5YEyMyp76HTaU8NNU1
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.neural_network import MLPClassifier
from sklearn.metrics import classification_report, confusion_matrix, precision_score, recall_score, f1_score
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.model_selection import train_test_split
import seaborn as sns
from tensorflow.keras.datasets import cifar10
import joblib

# Load CIFAR-10 Dataset
(x_train, y_train), (x_test, y_test) = cifar10.load_data()
x_train, x_test = x_train / 255.0, x_test / 255.0

# Flatten the input data for compatibility with MLPClassifier
x_train_flat = x_train.reshape(x_train.shape[0], -1)
x_test_flat = x_test.reshape(x_test.shape[0], -1)

# Split training data into training and validation sets
x_train_split, x_val_split, y_train_split, y_val_split = train_test_split(
    x_train_flat, y_train, test_size=0.2, random_state=42)

# Build Baseline Model
baseline_model = MLPClassifier(hidden_layer_sizes=(128, 256, 128),
                                activation='relu',
                                solver='adam',
                                max_iter=20,
                                batch_size=128,
                                random_state=42,
                                verbose=True)

# Train the baseline model
baseline_model.fit(x_train_split, y_train_split.ravel())

# Save the trained model
joblib.dump(baseline_model, 'baseline_model.pkl')

# Plot Training Results (Loss Curve)
def plot_training_results(model):
    plt.figure(figsize=(10, 5))
    plt.plot(model.loss_curve_, label='Training Loss')
    plt.title('Loss over Iterations')
    plt.xlabel('Iteration')
    plt.ylabel('Loss')
    plt.legend()
    plt.show()

plot_training_results(baseline_model)

# Evaluate Model Performance
train_accuracy = baseline_model.score(x_train_split, y_train_split)
val_accuracy = baseline_model.score(x_val_split, y_val_split)
test_accuracy = baseline_model.score(x_test_flat, y_test)

print("Training Accuracy:", train_accuracy)
print("Validation Accuracy:", val_accuracy)
print("Test Accuracy:", test_accuracy)

# Predictions
predictions = baseline_model.predict(x_test_flat)

# Classification Report
print("\nClassification Report:")
print(classification_report(y_test, predictions, digits=4))

# Precision, Recall, F1-Score
precision = precision_score(y_test, predictions, average='weighted')
recall = recall_score(y_test, predictions, average='weighted')
f1 = f1_score(y_test, predictions, average='weighted')

print("Precision:", precision)
print("Recall:", recall)
print("F1-Score:", f1)

# Confusion Matrix
conf_matrix = confusion_matrix(y_test, predictions)
plt.figure(figsize=(10, 8))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=range(10), yticklabels=range(10))
plt.title('Confusion Matrix')
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.show()

# Part 1.b - Increase Model Complexity
complex_model = MLPClassifier(hidden_layer_sizes=(256, 512, 256, 128),
                               activation='relu',
                               solver='adam',
                               max_iter=20,
                               batch_size=128,
                               random_state=42,
                               verbose=True)

# Train complex model
complex_model.fit(x_train_split, y_train_split.ravel())

# Save the complex model
joblib.dump(complex_model, 'complex_model.pkl')

# Plot results for complex model
plot_training_results(complex_model)

# Evaluate complex model
complex_predictions = complex_model.predict(x_test_flat)

print("\nClassification Report for Complex Model:")
print(classification_report(y_test, complex_predictions, digits=4))
train_accuracy2 = complex_model.score(x_train_split, y_train_split)
val_accuracy2 = complex_model.score(x_val_split, y_val_split)
test_accuracy2 = complex_model.score(x_test_flat, y_test)

print("Training Accuracy:", train_accuracy2)
print("Validation Accuracy:", val_accuracy2)
print("Test Accuracy:", test_accuracy2)


complex_precision = precision_score(y_test, complex_predictions, average='weighted')
complex_recall = recall_score(y_test, complex_predictions, average='weighted')
complex_f1 = f1_score(y_test, complex_predictions, average='weighted')

print("Complex Model Precision:", complex_precision)
print("Complex Model Recall:", complex_recall)
print("Complex Model F1-Score:", complex_f1)

conf_matrix_complex = confusion_matrix(y_test, complex_predictions)
plt.figure(figsize=(10, 8))
sns.heatmap(conf_matrix_complex, annot=True, fmt='d', cmap='Blues', xticklabels=range(10), yticklabels=range(10))
plt.title('Confusion Matrix - Complex Model')
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.show()